# build your own @vue/reactivity

VUE 的响应式实现来源于十分朴素的需求。例如当`text`变化时，也希望`document.body.innerText`里的内容也随之变化。
```js mark=3
let text = "Hello world" 
document.body.innerText = text
text = "Hi world"
```

再比如，当下面的`a`或者`b`变化时，希望`x`也随之变化
```js mark=4
let a = 1;
let b = 1;
let x = a + b;
a = 2
```
现在，JavaScript还无法像刚才设想的那样进行执行。我们不妨换个思路，将刚才提到的“随之变化”都视作一个变量变化后的**副作用**。上面的例子中**副作用**的代码都比较简单，只有一行，而**副作用**的代码也可以是多行的，比如
```js mark=3:4
let a = 1;
let b = 1;
let x = a + b;
console.log(x)
a = 2
``` 
要在一个变量变化时，同时执行多行**副作用**代码，就需要将这些代码放入一个“容器”当中，而Javascript中的**函数**为我们提供这样的能力！
```js mark=2:4
const obj = { x: 1, y: 1 }
function effect() {
  let sum = obj.x + obj.y
  console.log(sum)
}
obj.x = 2
```
进而，我们可以把这个包裹着副作用代码段的函数叫做**副作用函数**。
## 响应式数据与副作用函数

<CH.Scrollycoding>
### 响应式数据定义
我们最初的需求是当`obj`变量变化时，自动重新执行`effect`函数。如果`obj`变量能做这点，就称它为**响应式变量**。

```js index.js  
const obj = { x: 1, y: 1 }
function effect() {
  let sum = obj.x + obj.y
  console.log(sum)
}
effect()
obj.x = 2
```

---

### 响应式数据的实现思路
仔细观察例子，在`effect`中我们读取了`obj`的属性，又在最后设置了`obj`的属性。换句话说，
- 当副作用函数 effect 执行时，会触发字段 obj.x 的读取操作；
- 当修改 obj.x 的值时，会触发字段 obj.x 的设置操作。

通过拦截`obj`对象的读取和设置操作，在读取时，把`effect`存到某个地方去，并在设置时，从那个地方取回`effect`并执行，我们就能将`obj`变成响应式数据。
```js index.js  focus=3[12:25],7
const obj = { x: 1, y: 1 }
function effect() {
  let sum = obj.x + obj.y
  console.log(sum)
}
effect()
obj.x = 2
```

---

### 响应式数据的基本实现1
如何拦截一个对象的读取和设置操作呢？可以采用ES6中[`Proxy`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)来实现。
通过它的`get`与`set`就能实现对原始数据的代理，在[get](focus://index.js#8[3:5])与[set](focus://index.js#15[3:5])函数中，我们可以对`effect`进行额外的操作。

另一个问题，应当将`effect`存到什么样的数据结构中去呢？[Set](focus://index.js#1[20:22])是个不错的选择，读取方便，并且当我们有多个`effect`时，它能自动去重。在例子`effect`中我们既读取了`x`又读取了`y`，如果不去重，`effect`会被添加两次也会被执行两次，这是没有必要的。
> 注意：现在我们在`effect`中读取是代理之后的`data`，设置时也是设置的`data`的属性，而不是原始数据`obj`的！

注意到[effect函数名是硬编码在get](focus://index.js#8:10)中的，它可以完全不叫这个名字，下一节我们解决这个问题。
```js index.js 
const bucket = new Set()

// 原始数据
const obj = { x: 1, y: 1 }
// 对原始数据的代理
const data = new Proxy(obj, {
  // 拦截读取操作
  get(target, key) {
    // 将副作用函数 effect 添加到存储副作用函数的桶中
    bucket.add(effect)
    // 返回属性值
    return target[key]
  },
  // 拦截设置操作
  set(target, key, newVal) {
    // 设置属性值
    target[key] = newVal
    // 把副作用函数从桶里取出并执行
    bucket.forEach(fn => fn())
    // 返回 true 代表设置操作成功
    return true
  }
})
function effect() {
  let sum = data.x + data.y
  console.log(sum)
}
effect()
setTimeout(() => {
  data.x = 2
}, 1000)
```

---

### 响应式数据的实现
用一个全局变量`activeEffect`存储被注册的副作用函数，`effect`转变为接受一个副作用函数`fn`为参数，并注册执行副作用函数的高级函数。
另外，我们还需要修改get函数的内容，将全局变量`activeEffect`放入`Set`中，而不是之前`effect`函数。

```js index.js focus=1:9,19:20,34:37
// 用一个全局变量存储被注册的副作用函数
let activeEffect
// effect 函数用于注册副作用函数
function effect(fn) {
  // 当调用 effect 注册副作用函数时，将副作用函数 fn 赋值给 activeEffect
  activeEffect = fn
  // 执行副作用函数
  fn()
}

const bucket = new Set()

// 原始数据
const obj = { x: 1, y: 1 }
// 对原始数据的代理
const data = new Proxy(obj, {
  // 拦截读取操作
  get(target, key) {
    // 将副作用函数 activeEffect 添加到存储副作用函数的桶中
    bucket.add(activeEffect)
    // 返回属性值
    return target[key]
  },
  // 拦截设置操作
  set(target, key, newVal) {
    // 设置属性值
    target[key] = newVal
    // 把副作用函数从桶里取出并执行
    bucket.forEach(fn => fn())
    // 返回 true 代表设置操作成功
    return true
  }
})
effect(function() {
  let sum = data.x + data.y
  console.log(sum)
})
setTimeout(() => {
  data.x = 2
}, 1000)

```

---

#### 现有副作用函数存储数据结构的缺陷
如果我们为响应式变量`data`设置一个原本不存在的属性，比如在setTimeout中设置`data.z = 2`，会怎么样呢？
因为用effect函数注册副作用函数会立即执行该函数，所以第一行会输出`sum: 2`，当我们设置`data.z = 2`时，
因为`z`属性没有在副作用函数注册时被拦截，应该不会再次执行副作用函数，但实际输出如下，副作用函数还是被执行了
```js index.js focus=39 mark=11
// 用一个全局变量存储被注册的副作用函数
let activeEffect
// effect 函数用于注册副作用函数
function effect(fn) {
  // 当调用 effect 注册副作用函数时，将副作用函数 fn 赋值给 activeEffect
  activeEffect = fn
  // 执行副作用函数
  fn()
}

const bucket = new Set()

// 原始数据
const obj = { x: 1, y: 1 }
// 对原始数据的代理
const data = new Proxy(obj, {
  // 拦截读取操作
  get(target, key) {
    // 将副作用函数 activeEffect 添加到存储副作用函数的桶中
    bucket.add(activeEffect)
    // 返回属性值
    return target[key]
  },
  // 拦截设置操作
  set(target, key, newVal) {
    // 设置属性值
    target[key] = newVal
    // 把副作用函数从桶里取出并执行
    bucket.forEach(fn => fn())
    // 返回 true 代表设置操作成功
    return true
  }
})
effect(function() {
  let sum = data.x + data.y
  console.log("sum: ")
})
setTimeout(() => {
  data.z = 2
}, 1000)
```

```sh mark=2
sum: 2
sum: 2
```
为什么会这样呢？因为在data设置`z`属性时，触发了[set拦截函数](focus://index.js#26:33)，在函数中将`bucket`中每个函数都依次执行了一次，无论这个函数是否与新属性`z`有关。

---

#### 新的副作用函数存储数据结构
之所以会有上一节的问题，是因为我们没有在每一个属性值与副作用函数之间添加联系。最能体现建立联系这个功能的数据结构是**映射**，在Javascript中我们可以使用`Map`来完成某个对象的某些属性与副作用函数集合的映射。
更进一步的，我们可能需要为多个对象的多个属性添加与多个副作用函数的联系。那么我们可以使用下面的数据结构。

TODO: 图片

```js index.js mark=12,17:52
// 用一个全局变量存储被注册的副作用函数
let activeEffect
// effect 函数用于注册副作用函数
function effect(fn) {
  // 当调用 effect 注册副作用函数时，将副作用函数 fn 赋值给 activeEffect
  activeEffect = fn
  // 执行副作用函数
  fn()
}

// 新的存储副作用函数的数据结构
const bucket = new WeakMap();

// 原始数据
const obj = { x: 1, y: 1 }
// 对原始数据的代理
const data = new Proxy(obj, {
  // 拦截读取操作
  get(target, key) {
    // 没有 activeEffect，直接 return
    if (!activeEffect) return target[key]
    // 根据 target 从“桶”中取得 depsMap，它也是一个 Map 类型：key --> effects
    let depsMap = bucket.get(target)
    // 如果不存在 depsMap，那么新建一个 Map 并与 target 关联
    if (!depsMap) {
      bucket.set(target, (depsMap = new Map()))
    }
    // 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型，
    // 里面存储着所有与当前 key 相关联的副作用函数：effects
    let deps = depsMap.get(key)
    // 如果 deps 不存在，同样新建一个 Set 并与 key 关联
    if (!deps) {
      depsMap.set(key, (deps = new Set()))
    }
    // 最后将当前激活的副作用函数添加到“桶”里
    deps.add(activeEffect)
    // 返回属性值
    return target[key]
  },
  // 拦截设置操作
  set(target, key, newVal) {
    // 设置属性值
    target[key] = newVal
    // 根据 target 从桶中取得 depsMap，它是 key --> effects
    const depsMap = bucket.get(target)
    if (!depsMap) return
    // 根据 key 取得所有副作用函数 effects
    const effects = depsMap.get(key)
    // 执行副作用函数
    effects && effects.forEach(fn => fn())
  }
})

effect(function () {
  let sum = data.x + data.y
  console.log("sum:", sum)
})

setTimeout(() => {
  data.z = 2
}, 1000)
```
现在输出结果正常了：
```sh
sum: 2
```

---
进一步，可以将拦截函数的逻辑从Proxy中抽离出来，分别把逻辑封装到 [track](focus://track.js#1:14) 和 [trigger](focus://trigger.js#1:7) 函数内，这能为我们带来极大的灵活性。
<CH.Code>
```js index.js mark=21,30
// 用一个全局变量存储被注册的副作用函数
let activeEffect
// effect 函数用于注册副作用函数
function effect(fn) {
  // 当调用 effect 注册副作用函数时，将副作用函数 fn 赋值给 activeEffect
  activeEffect = fn
  // 执行副作用函数
  fn()
}

// 新的存储副作用函数的数据结构
const bucket = new WeakMap();

// 原始数据
const obj = { x: 1, y: 1 }
// 对原始数据的代理
const data = new Proxy(obj, {
  // 拦截读取操作
  get(target, key) {
    // 将副作用函数 activeEffect 添加到存储副作用函数的桶中
    track(target, key)
    // 返回属性值
    return target[key]
  },
  // 拦截设置操作
  set(target, key, newVal) {
    // 设置属性值
    target[key] = newVal
    // 把副作用函数从桶里取出并执行
    trigger(target, key)
  }
})

effect(function () {
  let sum = data.x + data.y
  console.log("sum:", sum)
})
setTimeout(() => {
  data.z = 2
}, 1000)
```
```js track.js
// 在 get 拦截函数内调用 track 函数追踪变化
function track(target, key) {
  // 没有 activeEffect，直接 return
  if (!activeEffect) return
  let depsMap = bucket.get(target)
  if (!depsMap) {
    bucket.set(target, (depsMap = new Map()))
  }
  let deps = depsMap.get(key)
  if (!deps) {
    depsMap.set(key, (deps = new Set()))
  }
  deps.add(activeEffect)
}
```
```js trigger.js
// 在 set 拦截函数内调用 trigger 函数触发变化
function trigger(target, key) {
  const depsMap = bucket.get(target)
  if (!depsMap) return
  const effects = depsMap.get(key)
  effects && effects.forEach(fn => fn())
}
```

</CH.Code>


</CH.Scrollycoding>

